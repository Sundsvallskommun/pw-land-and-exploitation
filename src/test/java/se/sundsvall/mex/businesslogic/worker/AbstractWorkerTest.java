package se.sundsvall.mex.businesslogic.worker;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.mockStatic;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoInteractions;
import static org.mockito.Mockito.verifyNoMoreInteractions;
import static org.mockito.Mockito.when;
import static se.sundsvall.mex.Constants.CASEDATA_KEY_PHASE_ACTION;
import static se.sundsvall.mex.Constants.CASEDATA_KEY_PHASE_STATUS;
import static se.sundsvall.mex.Constants.PHASE_ACTION_CANCEL;
import static se.sundsvall.mex.Constants.PHASE_ACTION_COMPLETE;
import static se.sundsvall.mex.Constants.PHASE_STATUS_WAITING;

import java.util.Map;
import java.util.UUID;
import java.util.stream.Stream;

import org.camunda.bpm.client.task.ExternalTask;
import org.camunda.bpm.client.task.ExternalTaskService;
import org.camunda.bpm.engine.variable.type.ValueType;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import se.sundsvall.dept44.requestid.RequestId;
import se.sundsvall.mex.Constants;
import se.sundsvall.mex.businesslogic.handler.FailureHandler;
import se.sundsvall.mex.integration.camunda.CamundaClient;
import se.sundsvall.mex.integration.casedata.CaseDataClient;

import generated.se.sundsvall.camunda.VariableValueDto;
import generated.se.sundsvall.casedata.ErrandDTO;
import generated.se.sundsvall.casedata.PatchErrandDTO;

@ExtendWith(MockitoExtension.class)
class AbstractWorkerTest {

	private static class Worker extends AbstractWorker {

		protected Worker(CamundaClient camundaClient, CaseDataClient caseDataClient, FailureHandler failureHandler) {
			super(camundaClient, caseDataClient, failureHandler);
		}

		@Override
		protected void executeBusinessLogic(ExternalTask externalTask, ExternalTaskService externalTaskService) {}
	} // Test class extending the abstract class containing the clearUpdateAvailable method

	private static final String MUNICIPALITY_ID = "2281";
	private static final String PHASE_ACTION = "phaseAction";
	private static final String PHASE_STATUS = "phaseStatus";

	@Mock
	private CamundaClient camundaClientMock;

	@Mock
	private ExternalTask externalTaskMock;

	@Mock
	private CaseDataClient caseDataClientMock;

	@Mock
	private FailureHandler failureHandlerMock;

	@Mock
	private ExternalTaskService externalTaskServiceMock;

	@Mock
	private Logger loggerMock;

	@Mock
	private ErrandDTO errandMock;

	@Captor
	ArgumentCaptor<PatchErrandDTO> patchCaptor;

	@InjectMocks
	private Worker worker;

	@Test
	void clearUpdateAvailable() {
		// Arrange
		final var uuid = UUID.randomUUID().toString();
		final var key = "updateAvailable";
		final var value = new VariableValueDto().type(ValueType.BOOLEAN.getName()).value(false);

		when(externalTaskMock.getProcessInstanceId()).thenReturn(uuid);

		// Act
		worker.clearUpdateAvailable(externalTaskMock);

		// Assert and verify
		verify(externalTaskMock).getProcessInstanceId();
		verify(camundaClientMock).setProcessInstanceVariable(uuid, key, value);
		verifyNoMoreInteractions(externalTaskMock, camundaClientMock);
		verifyNoInteractions(externalTaskServiceMock, failureHandlerMock);
	}

	@Test
	void setProcessInstanceVariable() {
		// Arrange
		final var uuid = UUID.randomUUID().toString();
		final var key = "someKey";
		final var value = new VariableValueDto().type(ValueType.STRING.getName()).value("someValue");

		when(externalTaskMock.getProcessInstanceId()).thenReturn(uuid);

		// Act
		worker.setProcessInstanceVariable(externalTaskMock, key, value);

		// Assert and verify
		verify(externalTaskMock).getProcessInstanceId();
		verify(camundaClientMock).setProcessInstanceVariable(uuid, key, value);
		verifyNoMoreInteractions(externalTaskMock, camundaClientMock);
		verifyNoInteractions(externalTaskServiceMock, failureHandlerMock);
	}

	@Test
	void execute() {
		// Arrange
		final var requestId = UUID.randomUUID().toString();

		when(externalTaskMock.getVariable(Constants.CAMUNDA_VARIABLE_REQUEST_ID)).thenReturn(requestId);

		// Mock static RequestId to verify that static method is being called
		try (MockedStatic<RequestId> requestIdMock = mockStatic(RequestId.class)) {

			// Act
			worker.execute(externalTaskMock, externalTaskServiceMock);

			// Verify static method
			requestIdMock.verify(() -> RequestId.init(requestId));
		}

		verify(externalTaskMock).getVariable(Constants.CAMUNDA_VARIABLE_REQUEST_ID);
		verifyNoMoreInteractions(externalTaskMock);
		verifyNoInteractions(camundaClientMock, externalTaskServiceMock, failureHandlerMock);
	}

	@Test
	void getErrand() {
		// Arrange
		final var caseNumber = 666L;
		final var errand = new ErrandDTO();

		when(caseDataClientMock.getErrandById(MUNICIPALITY_ID, caseNumber)).thenReturn(errand);

		// Act, assert and verify
		assertThat(worker.getErrand(MUNICIPALITY_ID, caseNumber)).isEqualTo(errand);
		verify(caseDataClientMock).getErrandById(MUNICIPALITY_ID, caseNumber);
		verifyNoMoreInteractions(externalTaskMock, caseDataClientMock);
		verifyNoInteractions(externalTaskServiceMock, camundaClientMock, failureHandlerMock);
	}

	@Test
	void logInfo() {
		// Mock static LoggerFactory to enable spy and to verify that static method is being called
		try (MockedStatic<LoggerFactory> loggerFactoryMock = Mockito.mockStatic(LoggerFactory.class)) {
			loggerFactoryMock.when(() -> LoggerFactory.getLogger(Worker.class)).thenReturn(loggerMock);

			// Act
			final var worker = new AbstractWorkerTest.Worker(null, null, null);
			worker.logInfo("message with parameters {} {}", "parameter1", "parameter2");

			// Assert and verify
			loggerFactoryMock.verify(() -> LoggerFactory.getLogger(Worker.class));
			verify(loggerMock).info("message with parameters {} {}", new Object[]{"parameter1", "parameter2"});
			verifyNoInteractions(caseDataClientMock, camundaClientMock, failureHandlerMock, externalTaskServiceMock, externalTaskMock);
		}
	}

	@Test
	void logException() {
		// Arrange
		final var id = "errandId";
		final var businessKey = "businessKey";

		when(externalTaskMock.getId()).thenReturn(id);
		when(externalTaskMock.getBusinessKey()).thenReturn(businessKey);

		// Mock static LoggerFactory to enable spy and to verify that static method is being called
		try (MockedStatic<LoggerFactory> loggerFactoryMock = Mockito.mockStatic(LoggerFactory.class)) {
			loggerFactoryMock.when(() -> LoggerFactory.getLogger(Worker.class)).thenReturn(loggerMock);

			// Act
			final var worker = new AbstractWorkerTest.Worker(null, null, null);
			final var exception = new Exception("testexception");
			worker.logException(externalTaskMock, exception);

			// Assert and verify
			loggerFactoryMock.verify(() -> LoggerFactory.getLogger(Worker.class));
			verify(loggerMock).error("Exception occurred in {} for task with id {} and businesskey {}", Worker.class.getSimpleName(), id, businessKey, exception);
			verify(externalTaskMock).getBusinessKey();
			verifyNoMoreInteractions(externalTaskMock);
			verifyNoInteractions(caseDataClientMock, camundaClientMock, failureHandlerMock);
		}
	}

	@Test
	void patchPhaseData() {
		// Arrange
		final var id = 678L;
		final var externalCaseId = UUID.randomUUID().toString();
		final var phase = "phase";

		when(errandMock.getId()).thenReturn(id);
		when(errandMock.getExternalCaseId()).thenReturn(externalCaseId);
		when(errandMock.getPhase()).thenReturn(phase);

		// Act
		worker.patchPhaseData(MUNICIPALITY_ID, errandMock, PHASE_ACTION, PHASE_STATUS);

		// Assert and verify
		verify(errandMock).getId();
		verify(errandMock).getExternalCaseId();
		verify(caseDataClientMock).patchErrand(eq(MUNICIPALITY_ID), eq(id), patchCaptor.capture());
		verifyNoMoreInteractions(caseDataClientMock, errandMock);
		verifyNoInteractions(externalTaskServiceMock, camundaClientMock, failureHandlerMock, externalTaskMock);

		assertThat(patchCaptor.getValue()).satisfies(patch -> {
			assertThat(patch).hasAllNullFieldsOrPropertiesExcept("externalCaseId", "phase", "extraParameters", "facilities");
			assertThat(patch.getExternalCaseId()).isEqualTo(externalCaseId);
			assertThat(patch.getPhase()).isEqualTo(phase);
			assertThat(patch.getExtraParameters()).containsExactlyInAnyOrderEntriesOf(Map.of(
				CASEDATA_KEY_PHASE_STATUS, PHASE_STATUS,
				CASEDATA_KEY_PHASE_ACTION, PHASE_ACTION));
		});
	}

	@Test
	void patchPhaseDataIfNotEqual_whenNotEqual() {
		// Arrange
		final var id = 678L;
		final var externalCaseId = UUID.randomUUID().toString();
		final var phase = "phase";


		when(errandMock.getId()).thenReturn(id);
		when(errandMock.getExternalCaseId()).thenReturn(externalCaseId);
		when(errandMock.getPhase()).thenReturn(phase);
		when(errandMock.getExtraParameters()).thenReturn(Map.of(CASEDATA_KEY_PHASE_STATUS, PHASE_STATUS + "_notEqual"));

		// Act
		worker.patchPhaseDataIfNotEqual(MUNICIPALITY_ID, errandMock, PHASE_ACTION, PHASE_STATUS);

		// Assert and verify
		verify(errandMock).getExtraParameters();
		verify(errandMock).getId();
		verify(errandMock).getExternalCaseId();
		verify(caseDataClientMock).patchErrand(eq(MUNICIPALITY_ID), eq(id), patchCaptor.capture());
		verifyNoMoreInteractions(caseDataClientMock, errandMock);
		verifyNoInteractions(externalTaskServiceMock, camundaClientMock, failureHandlerMock, externalTaskMock);

		assertThat(patchCaptor.getValue()).satisfies(patch -> {
			assertThat(patch).hasAllNullFieldsOrPropertiesExcept("externalCaseId", "phase", "extraParameters", "facilities");
			assertThat(patch.getExternalCaseId()).isEqualTo(externalCaseId);
			assertThat(patch.getPhase()).isEqualTo(phase);
			assertThat(patch.getExtraParameters()).containsExactlyInAnyOrderEntriesOf(Map.of(
				CASEDATA_KEY_PHASE_STATUS, PHASE_STATUS,
				CASEDATA_KEY_PHASE_ACTION, PHASE_ACTION));
		});
	}

	@Test
	void patchPhaseDataIfNotEqual_whenEqual() {
		// Arrange
		when(errandMock.getExtraParameters()).thenReturn(Map.of(CASEDATA_KEY_PHASE_STATUS, PHASE_STATUS));

		// Act
		worker.patchPhaseDataIfNotEqual(MUNICIPALITY_ID, errandMock, PHASE_ACTION, PHASE_STATUS);

		// Assert and verify
		verify(errandMock).getExtraParameters();
		verifyNoMoreInteractions(errandMock);
		verifyNoInteractions(externalTaskServiceMock, caseDataClientMock, camundaClientMock, failureHandlerMock, externalTaskMock);
	}

	@ParameterizedTest
	@MethodSource("isCancelRequestedArguments")
	void isCancelRequested(Map<String, String> extraParameters, boolean expectedResult) {
		// Arrange
		when(errandMock.getExtraParameters()).thenReturn(extraParameters);

		// Act, assert and verify
		assertThat(worker.isCancelRequested(errandMock)).isEqualTo(expectedResult);
		verifyNoInteractions(caseDataClientMock, camundaClientMock, failureHandlerMock, externalTaskServiceMock, externalTaskMock);
	}

	private static Stream<Arguments> isCancelRequestedArguments() {
		return Stream.of(
			Arguments.of(Map.of(CASEDATA_KEY_PHASE_ACTION, PHASE_ACTION_CANCEL, CASEDATA_KEY_PHASE_STATUS, PHASE_STATUS_WAITING), true),
			Arguments.of(null, false),
			Arguments.of(Map.of(CASEDATA_KEY_PHASE_ACTION, PHASE_ACTION_COMPLETE), false),
			Arguments.of(Map.of(CASEDATA_KEY_PHASE_STATUS, PHASE_ACTION_CANCEL), false),
			Arguments.of(Map.of(), false));
	}
}
