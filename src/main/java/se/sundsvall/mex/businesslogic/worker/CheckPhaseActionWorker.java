package se.sundsvall.mex.businesslogic.worker;

import static se.sundsvall.mex.Constants.CAMUNDA_VARIABLE_PHASE_ACTION;
import static se.sundsvall.mex.Constants.PHASE_ACTION_COMPLETE;
import static se.sundsvall.mex.Constants.PHASE_ACTION_UNKNOWN;

import java.util.HashMap;
import java.util.Map;

import org.camunda.bpm.client.spring.annotation.ExternalTaskSubscription;
import org.camunda.bpm.client.task.ExternalTask;
import org.camunda.bpm.client.task.ExternalTaskHandler;
import org.camunda.bpm.client.task.ExternalTaskService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import se.sundsvall.mex.businesslogic.handler.FailureHandler;
import se.sundsvall.mex.integration.camunda.CamundaClient;

@Component
@ExternalTaskSubscription("checkPhaseActionTask")
public class CheckPhaseActionWorker extends AbstractWorker implements ExternalTaskHandler {

	private static final Logger LOGGER = LoggerFactory.getLogger(CheckPhaseActionWorker.class);

	private final FailureHandler failureHandler;

	public CheckPhaseActionWorker(FailureHandler failureHandler, CamundaClient camundaClient) {
		super(camundaClient);
		this.failureHandler = failureHandler;
	}

	@Override
	public void execute(ExternalTask externalTask, ExternalTaskService externalTaskService) {
		try {
			LOGGER.info("Execute task for checking if phase action is complete or not");

			// 1.Clear updateAvailable. This should always be done first
			clearUpdateAvailable(externalTask);

			// 2. Fetch data from datasource. (In this template the source is process variables, but in a real process this would be
			// a integration call)
			Integer updateCounter = externalTask.getVariable("updateCounter");
			LOGGER.info("updateCounter: {}", updateCounter);

			// 3. Check if it is ok to move to the next task (no data is missing).
			final Map<String, Object> processVariables = new HashMap<>();
			if ("will_need_two_updates".equals(externalTask.getBusinessKey())) {
				if (updateCounter == null) {
					updateCounter = 1;
				} else {
					updateCounter = updateCounter + 1;
				}

				if (updateCounter <= 2) { // phase is not yet complete
					LOGGER.info("More updates will be needed");
					processVariables.put(CAMUNDA_VARIABLE_PHASE_ACTION, PHASE_ACTION_UNKNOWN);
				} else {
					LOGGER.info("Updates done");
					processVariables.put(CAMUNDA_VARIABLE_PHASE_ACTION, PHASE_ACTION_COMPLETE);
				}
			} else {
				processVariables.put(CAMUNDA_VARIABLE_PHASE_ACTION, PHASE_ACTION_COMPLETE);
			}

			// 4. Complete
			processVariables.put("updateCounter", updateCounter);
			externalTaskService.complete(externalTask, processVariables);
		} catch (final Exception exception) {
			LOGGER.error("Exception occurred in execution for task with id {} and businesskey {}", externalTask.getId(), externalTask.getBusinessKey());

			failureHandler.handleException(externalTaskService, externalTask, exception.getMessage());
		}
	}
}
